## 1. BBR拥塞算法

> [DTS/DRC 2018 双十一总结](https://www.atatech.org/articles/124525?spm=ata.home.0.0.3c417536u0Jc4r&flag_data_from=home_algorithm_article)

 TCP作为一个保证数据准确性的流协议在内部实现了数据包切割，重传，组装，定序等操作，基本上大多数的数据交互都是建立在TCP上。下面是比较常见的丢包原因：

   1.网络链路原因，包括物理链路丢包，错报。交换机丢包错报

   2.目标端接受慢，包括内核态和用户态。内核态慢可能会导致持续性丢包。用户态慢可能会导致短时丢包。

 

  TCP作为一个通用的传输协议，在发现丢包的时候会采用拥塞控制算法来避免持续的发送造成无意义的丢包。目前使用比较多的是cubic算法。然后再4.9内核引入了BBR算法。BBR之前的绝大部分的拥塞算法都是基于反馈的拥塞算法，也就是当发现ACK超时之后，就认为是网络丢包了，所以就会减小发送窗口，从而减小发送数据的速度。cubic的拥塞退让是比较迅速的，直接拥塞窗口减半。后续的快启动和指数启动都是为了尽快的恢复发送窗口。但是不难看出，要恢复到之前的发送速度，需要不确定个来回(RTT),假设这中间又发生了偶发性的丢包，速度很难恢复。

 

  接下来重点看一下BBR是如何"拯救世界"的。 首先先明确几个常见的网络术语：

   RTT: round-trip time, 这个认为是一个数据包来回的时间。 ping 使用的icmp包回显的时间就可以认为是网络的RTT。网络单程时间可以认为 RTT / 2

   RTO: 重传超时，也就是多久没有收到 seq A 的ack之后就要进行一次重传。 重传可能导致 retran 和Dup Packet

   *BtlBW* : bottleneck bandwidth, 整个网络链路上带宽最小的瓶颈点。A 到 B 有三段网络 l ->(3Gb) m ->(2Gb) n ->(7Gb) q, 那么他的BtlBW 在 n->m 段上。发送速度不会超过 2Gb/s

*RTprop:* round-trip propagation time, 从 A 到 B最小的时延。基本可以认为是 RTT / 2

   BDP:bandwidth**-**delay product， 意思就是有一条链路，因为物理链路总是物理信号，当这个物理信号填满这个物理链路之后，就是BDP的数值。明显他应该等于发送速度 * RTprop. 更简单的理解就是填满一个水管需要的水量。

  其实很多时候应用可能感知不到网络的一些变化，比如应用写的数据很少。或者在拥塞控制之前完成了数据发送。或者一个拥塞控制造成了一次请求慢了 0.5ms. 这些可能都感觉不太明显。 但是对于DRC这种对于长传速度非常敏感的实时服务，如果发送速度受限会造成非常严重的后果。之前发送cwnd在171左右。真实的网络流量上限只有 cwnd * MSS(大部分为1460) 约为 250KB左右。虽然长途传输经过了压缩。但是当数据量上去之后还是出现了延迟。

  下面大体分析一下BBR是如何尽量将发送速度接近到BtlBW。

   1.不再依赖于丢包率来改变cwnd

   2.测量每一个包的RTT来计算最小的RTT

   3.每次接受ACK都会评估链路的最大发送的速度。(小于等于Min(BtlBW))

   4.发送速度是BBR的判断是否可以发送数据的首要条件，这个值尽量贴近BtlBW。

 